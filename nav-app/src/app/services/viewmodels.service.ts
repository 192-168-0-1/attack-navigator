import { EventEmitter, Injectable, Output } from '@angular/core';
import { Gradient, TechniqueVM, ViewModel } from '../classes';
import { DataService } from './data.service';
import { evaluate } from 'mathjs';
import * as is from 'is_js';

@Injectable({
    providedIn: 'root'
})
export class ViewModelsService {
    @Output() onSelectionChange = new EventEmitter<any>();
    pinnedCell = "";

    constructor(private dataService: DataService) { }

    viewModels: ViewModel[] = [];

    /**
     * Emit event when technique selection changes
     */
    selectionChanged() {
        this.onSelectionChange.emit();
    }

    /**
     * Create and return a new viewModel
     * @param {string} name the viewmodel name
     * @param {string} domainVersionID the ID of the domain & version
     * @return {ViewModel} the created ViewModel
     */
    newViewModel(name: string, domainVersionID: string) {
        let vm = new ViewModel(name, "vm" + this.getNonce(), domainVersionID, this.dataService);
        this.viewModels.push(vm);
        return vm;
    }

    nonce: number = 0;
    /**
     * Get a nonce.
     * @return a number that will never be regenerated by sequential calls to getNonce.
     *         Note: this applies on a session-by-session basis, nonces are not
     *         unique between app instances.
     */
    getNonce(): number {
        return this.nonce++;
    }

    /**
     * Destroy the viewmodel completely Nessecary if tab is closed!
     * @param vm viewmodel to destroy.
     */
    destroyViewModel(vm: ViewModel): void {
        for (let i = 0; i < this.viewModels.length; i++) {
            if (this.viewModels[i] == vm) {
                this.viewModels.splice(i, 1)
                return;
            }
        }
    }

    /**
     * layer combination operation
     * @param  domainVersionID  domain & version ID
     * @param  scoreExpression  math expression of score expression
     * @param  scoreVariables   variables in math expression, mapping to viewmodel they correspond to
     * @param  comments         what viewmodel to inherit comments from
     * @param  links            what viewmodel to inherit links from
     * @param  metadata         what viewmodel to inherit technique metadata from
     * @param  coloring         what viewmodel to inherit manual colors from
     * @param  enabledness      what viewmodel to inherit state from
     * @param  layerName        new layer name
     * @param  filters          viewmodel to inherit filters from
     * @return                  new viewmodel inheriting above properties
     */
    layerLayerOperation(domainVersionID: string, scoreExpression: string, scoreVariables: Map<string, ViewModel>, comments: ViewModel, links: ViewModel, metadata: ViewModel, gradient: ViewModel, coloring: ViewModel, enabledness: ViewModel, layerName: string, filters: ViewModel, legendItems: ViewModel): ViewModel {
        let result = new ViewModel("layer by operation", "vm" + this.getNonce(), domainVersionID, this.dataService);

        if (scoreExpression) {
            scoreExpression = scoreExpression.toLowerCase() //should be enforced by input, but just in case
            let score_min = Infinity;
            let score_max = -Infinity;

            //get list of all technique IDs used in the VMs
            let techniqueIDs = new Set<string>();
            scoreVariables.forEach(function (vm, key) {
                vm.techniqueVMs.forEach(function (techniqueVM, techniqueID) {
                    techniqueIDs.add(techniqueID);
                })
            })
            //attempt to evaluate without a scope to catch the case of a static assignment
            try {
                // evaluate with an empty scope
                let mathResult = evaluate(scoreExpression, {});
                // if it didn't except after this, it evaluated to a single result.
                console.debug("score expression evaluated to single result to be applied to all techniques");
                if (is.boolean(mathResult)) {
                    mathResult = mathResult ? "1" : "0"; //boolean to binary
                } else if (is.not.number(mathResult)) { //user inputted something weird, complain about it
                    throw { message: "math result ( " + mathResult + " ) is not a number" };
                }
                // if it didn't error, and outputted a single value, apply this to all techniques.
                result.initializeScoresTo = String(mathResult); //initialize scores to this value
                score_min = mathResult;
                score_max = mathResult;
            } catch (err) { //couldn't evaluate with empty scope, build scope for each technique
                // compute the score of each techniqueID
                techniqueIDs.forEach(function (technique_id) {
                    let new_tvm = new TechniqueVM(technique_id);
                    let scope = {};
                    let misses = 0; //number of times a VM is missing the value
                    scoreVariables.forEach(function (vm, key) {
                        let scoreValue: number;
                        if (!vm.hasTechniqueVM_id(technique_id)) { //missing technique
                            scoreValue = 0;
                            misses++;
                        } else { //technique exists
                            let score = vm.getTechniqueVM_id(technique_id).score;
                            if (score == "") {
                                scoreValue = 0;
                                misses++;
                            } else if (isNaN(Number(score))) {
                                scoreValue = 0;
                                misses++;
                            } else {
                                scoreValue = Number(score);
                            }
                        }
                        scope[key] = scoreValue;
                    });
                    //don't record a result if none of VMs had a score for this technique
                    //did at least one technique have a score for this technique?
                    if (misses < scoreVariables.size) {
                        let mathResult = evaluate(scoreExpression, scope);
                        if (is.boolean(mathResult)) {
                            mathResult = mathResult ? "1" : "0"; //boolean to binary
                        } else if (is.not.number(mathResult)) { //user inputted something weird, complain about it
                            throw { message: "math result ( " + mathResult + " ) is not a number" };
                        }
                        new_tvm.score = String(mathResult);
                        result.techniqueVMs.set(technique_id, new_tvm);

                        score_min = Math.min(score_min, mathResult);
                        score_max = Math.max(score_max, mathResult);
                    }
                })
            }
            //don't do gradient if there's no range of values
            if (score_min != score_max) {
                // set up gradient according to result range
                if (score_min != Infinity) result.gradient.minValue = score_min;
                if (score_max != -Infinity) result.gradient.maxValue = score_max;
                // if it's a binary range, set to transparentblue gradient
                if (score_min == 0 && score_max == 1) result.gradient.setGradientPreset("transparentblue");
            }
        }


        /**
         * Inherit a field from a vm
         * @param  {ViewModel} inherit_vm the viewModel to inherit from
         * @param  {string}    fieldname  the field to inherit from the viewmodel
         */
        function inherit(inherit_vm: ViewModel, fieldname: string) {
            inherit_vm.techniqueVMs.forEach(function (inherit_TVM) {
                let tvm = result.hasTechniqueVM_id(inherit_TVM.technique_tactic_union_id) ? result.getTechniqueVM_id(inherit_TVM.technique_tactic_union_id) : new TechniqueVM(inherit_TVM.technique_tactic_union_id)
                tvm[fieldname] = inherit_TVM[fieldname];
                result.techniqueVMs.set(inherit_TVM.technique_tactic_union_id, tvm);
            })
        }

        if (comments) inherit(comments, "comment");
        if (links) inherit(links, "links");
        if (metadata) inherit(metadata, "metadata");
        if (coloring) inherit(coloring, "color");
        if (enabledness) inherit(enabledness, "enabled");

        if (filters) { //copy filter settings
            result.filters.deserialize(JSON.parse(filters.filters.serialize()))
        }

        if (legendItems) {
            result.legendItems = JSON.parse(JSON.stringify(legendItems.legendItems));
        }

        if (gradient) {
            result.gradient = new Gradient();
            result.gradient.deserialize(gradient.gradient.serialize());
        }

        result.name = layerName;
        this.viewModels.push(result)
        result.updateGradient();
        return result;
    } //end layer layer operation
}
